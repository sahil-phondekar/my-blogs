"use strict";(self.webpackChunkmy_blogs=self.webpackChunkmy_blogs||[]).push([[875],{5629:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>r,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"react-js/deep-dive/updating-objects","title":"Updating Object State Immutably in React","description":"In React, it\'s important to update state immutably, meaning that you should not modify the existing state object directly. Instead, you should create a new object that includes the updated values, which helps React track changes and trigger the necessary re-renders.","source":"@site/docs/react-js/deep-dive/updating-objects.md","sourceDirName":"react-js/deep-dive","slug":"/react-js/deep-dive/updating-objects","permalink":"/my-blogs/docs/react-js/deep-dive/updating-objects","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Updating State Based on Old State in React","permalink":"/my-blogs/docs/react-js/deep-dive/updating-state"},"next":{"title":"Lifting State Up in React","permalink":"/my-blogs/docs/react-js/deep-dive/lifting-state"}}');var a=n(4848),i=n(8453);const r={sidebar_position:2},o="Updating Object State Immutably in React",d={},c=[{value:"Why Immutability is Important",id:"why-immutability-is-important",level:2},{value:"1. <strong>Using <code>useState</code> Hook with Functional Components</strong>",id:"1-using-usestate-hook-with-functional-components",level:2},{value:"Example: Updating an Object in <code>useState</code>",id:"example-updating-an-object-in-usestate",level:3},{value:"Explanation:",id:"explanation",level:3},{value:"2. <strong>Nested Objects</strong>",id:"2-nested-objects",level:2},{value:"Example: Updating Nested Object State",id:"example-updating-nested-object-state",level:3},{value:"Explanation:",id:"explanation-1",level:3},{value:"3. <strong>Using <code>Object.assign()</code> (Alternative to Spread Operator)</strong>",id:"3-using-objectassign-alternative-to-spread-operator",level:2},{value:"Example with <code>Object.assign()</code>:",id:"example-with-objectassign",level:3},{value:"4. <strong>Using <code>useReducer</code> for Complex State Updates (Advanced)</strong>",id:"4-using-usereducer-for-complex-state-updates-advanced",level:2},{value:"Summary of Immutability Best Practices:",id:"summary-of-immutability-best-practices",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,i.R)(),...e.components};return(0,a.jsxs)(a.Fragment,{children:[(0,a.jsx)(t.header,{children:(0,a.jsx)(t.h1,{id:"updating-object-state-immutably-in-react",children:"Updating Object State Immutably in React"})}),"\n",(0,a.jsxs)(t.p,{children:["In React, it's important to update state ",(0,a.jsx)(t.strong,{children:"immutably"}),", meaning that you should not modify the existing state object directly. Instead, you should create a ",(0,a.jsx)(t.strong,{children:"new object"})," that includes the updated values, which helps React track changes and trigger the necessary re-renders."]}),"\n",(0,a.jsx)(t.h2,{id:"why-immutability-is-important",children:"Why Immutability is Important"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Predictability"}),": React needs to know when state has changed in order to trigger re-renders. If you modify the state directly, React won\u2019t be able to detect the change because the reference to the state object remains the same."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Performance"}),": React uses a ",(0,a.jsx)(t.strong,{children:"shallow comparison"})," to check if the state has changed. If you mutate the state directly, the object reference doesn\u2019t change, and React might not re-render your component."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Debugging"}),": Keeping state immutable helps you avoid unintended side effects, making it easier to reason about and debug your application."]}),"\n"]}),"\n",(0,a.jsx)(t.h1,{id:"how-to-update-object-state-immutably",children:"How to Update Object State Immutably"}),"\n",(0,a.jsxs)(t.h2,{id:"1-using-usestate-hook-with-functional-components",children:["1. ",(0,a.jsxs)(t.strong,{children:["Using ",(0,a.jsx)(t.code,{children:"useState"})," Hook with Functional Components"]})]}),"\n",(0,a.jsx)(t.p,{children:"To update an object in the state immutably, you should create a new object and copy the old properties over, then update the specific property that you want to change."}),"\n",(0,a.jsxs)(t.h3,{id:"example-updating-an-object-in-usestate",children:["Example: Updating an Object in ",(0,a.jsx)(t.code,{children:"useState"})]}),"\n",(0,a.jsxs)(t.p,{children:["Let's say you have an object in the state that represents a ",(0,a.jsx)(t.strong,{children:"user profile"}),", and you want to update just one field (e.g., the ",(0,a.jsx)(t.code,{children:"name"}),")."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import React, { useState } from 'react';\n\nfunction Profile() {\n  const [user, setUser] = useState({\n    name: 'John',\n    age: 30,\n    location: 'New York',\n  });\n\n  const updateName = () => {\n    // Updating the 'name' field immutably\n    setUser(prevUser => ({\n      ...prevUser,  // Spread the previous user object\n      name: 'Alice', // Update the 'name' field\n    }));\n  };\n\n  return (\n    <div>\n      <h1>Name: {user.name}</h1>\n      <p>Age: {user.age}</p>\n      <p>Location: {user.location}</p>\n      <button onClick={updateName}>Change Name</button>\n    </div>\n  );\n}\n\nexport default Profile;\n"})}),"\n",(0,a.jsx)(t.h3,{id:"explanation",children:"Explanation:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.code,{children:"...prevUser"})}),": The ",(0,a.jsxs)(t.strong,{children:["spread operator (",(0,a.jsx)(t.code,{children:"..."}),")"]})," copies all properties from the previous state (",(0,a.jsx)(t.code,{children:"prevUser"}),") into a new object."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.code,{children:"name: 'Alice'"})}),": You then update the specific field (",(0,a.jsx)(t.code,{children:"name"}),"), while all other properties (",(0,a.jsx)(t.code,{children:"age"}),", ",(0,a.jsx)(t.code,{children:"location"}),") remain unchanged."]}),"\n"]}),"\n",(0,a.jsxs)(t.h2,{id:"2-nested-objects",children:["2. ",(0,a.jsx)(t.strong,{children:"Nested Objects"})]}),"\n",(0,a.jsxs)(t.p,{children:["If your state contains ",(0,a.jsx)(t.strong,{children:"nested objects"})," (objects inside objects), you should also update those properties immutably by spreading the parent object, and then further spreading or updating the nested objects."]}),"\n",(0,a.jsx)(t.h3,{id:"example-updating-nested-object-state",children:"Example: Updating Nested Object State"}),"\n",(0,a.jsxs)(t.p,{children:["Suppose your state looks like this, where ",(0,a.jsx)(t.code,{children:"address"})," is a nested object:"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import React, { useState } from 'react';\n\nfunction UserProfile() {\n  const [user, setUser] = useState({\n    name: 'John',\n    age: 30,\n    address: {\n      city: 'New York',\n      zipCode: '10001',\n    },\n  });\n\n  const updateCity = () => {\n    setUser(prevUser => ({\n      ...prevUser, // Copy the outer user object\n      address: {\n        ...prevUser.address, // Copy the previous address object\n        city: 'Los Angeles', // Update just the 'city'\n      },\n    }));\n  };\n\n  return (\n    <div>\n      <h1>{user.name}</h1>\n      <p>Age: {user.age}</p>\n      <p>City: {user.address.city}</p>\n      <p>Zip Code: {user.address.zipCode}</p>\n      <button onClick={updateCity}>Change City</button>\n    </div>\n  );\n}\n\nexport default UserProfile;\n"})}),"\n",(0,a.jsx)(t.h3,{id:"explanation-1",children:"Explanation:"}),"\n",(0,a.jsxs)(t.ul,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.code,{children:"...prevUser"})}),": This spreads the outer ",(0,a.jsx)(t.code,{children:"user"})," object, keeping all its properties."]}),"\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.code,{children:"...prevUser.address"})}),": This spreads the ",(0,a.jsx)(t.code,{children:"address"})," object, so that the ",(0,a.jsx)(t.code,{children:"city"})," is the only property getting updated, while the other properties in ",(0,a.jsx)(t.code,{children:"address"})," (like ",(0,a.jsx)(t.code,{children:"zipCode"}),") stay the same."]}),"\n"]}),"\n",(0,a.jsxs)(t.h2,{id:"3-using-objectassign-alternative-to-spread-operator",children:["3. ",(0,a.jsxs)(t.strong,{children:["Using ",(0,a.jsx)(t.code,{children:"Object.assign()"})," (Alternative to Spread Operator)"]})]}),"\n",(0,a.jsxs)(t.p,{children:["If you're working in an environment where the spread operator is not available (e.g., older JavaScript versions), you can use ",(0,a.jsx)(t.code,{children:"Object.assign()"})," to create a new object and copy properties from the old object."]}),"\n",(0,a.jsxs)(t.h3,{id:"example-with-objectassign",children:["Example with ",(0,a.jsx)(t.code,{children:"Object.assign()"}),":"]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"const updateCity = () => {\n  setUser(prevUser => Object.assign({}, prevUser, {\n    address: Object.assign({}, prevUser.address, {\n      city: 'Los Angeles',\n    }),\n  }));\n};\n"})}),"\n",(0,a.jsxs)(t.p,{children:["In this case, ",(0,a.jsx)(t.code,{children:"Object.assign()"})," is used to create a new object by copying the old properties and updating the specific fields."]}),"\n",(0,a.jsxs)(t.h2,{id:"4-using-usereducer-for-complex-state-updates-advanced",children:["4. ",(0,a.jsxs)(t.strong,{children:["Using ",(0,a.jsx)(t.code,{children:"useReducer"})," for Complex State Updates (Advanced)"]})]}),"\n",(0,a.jsxs)(t.p,{children:["When state updates become complex (e.g., deeply nested updates), using ",(0,a.jsx)(t.code,{children:"useReducer"})," is a great alternative. It allows for more structured and manageable state updates."]}),"\n",(0,a.jsx)(t.pre,{children:(0,a.jsx)(t.code,{className:"language-js",children:"import React, { useReducer } from 'react';\n\nconst initialState = {\n  name: 'John',\n  age: 30,\n  address: {\n    city: 'New York',\n    zipCode: '10001',\n  },\n};\n\nfunction reducer(state, action) {\n  switch (action.type) {\n    case 'UPDATE_CITY':\n      return {\n        ...state,\n        address: {\n          ...state.address,\n          city: action.payload, // Update the city\n        },\n      };\n    default:\n      return state;\n  }\n}\n\nfunction UserProfile() {\n  const [state, dispatch] = useReducer(reducer, initialState);\n\n  const updateCity = () => {\n    dispatch({ type: 'UPDATE_CITY', payload: 'Los Angeles' });\n  };\n\n  return (\n    <div>\n      <h1>{state.name}</h1>\n      <p>Age: {state.age}</p>\n      <p>City: {state.address.city}</p>\n      <button onClick={updateCity}>Change City</button>\n    </div>\n  );\n}\n\nexport default UserProfile;\n"})}),"\n",(0,a.jsx)(t.h2,{id:"summary-of-immutability-best-practices",children:"Summary of Immutability Best Practices:"}),"\n",(0,a.jsxs)(t.ol,{children:["\n",(0,a.jsxs)(t.li,{children:[(0,a.jsx)(t.strong,{children:"Never modify the state directly"}),". Always use a new object to represent the updated state."]}),"\n",(0,a.jsxs)(t.li,{children:["Use the ",(0,a.jsx)(t.strong,{children:"spread operator"})," (",(0,a.jsx)(t.code,{children:"..."}),") to copy the previous state and update the necessary properties."]}),"\n",(0,a.jsxs)(t.li,{children:["For ",(0,a.jsx)(t.strong,{children:"nested objects"}),", spread both the parent and child objects to ensure the changes are made immutably."]}),"\n",(0,a.jsxs)(t.li,{children:["Consider using ",(0,a.jsx)(t.strong,{children:(0,a.jsx)(t.code,{children:"useReducer"})})," for managing complex or deeply nested state updates."]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,i.R)(),...e.components};return t?(0,a.jsx)(t,{...e,children:(0,a.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>r,x:()=>o});var s=n(6540);const a={},i=s.createContext(a);function r(e){const t=s.useContext(i);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(a):e.components||a:r(e.components),s.createElement(i.Provider,{value:t},e.children)}}}]);