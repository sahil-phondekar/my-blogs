"use strict";(self.webpackChunkmy_blogs=self.webpackChunkmy_blogs||[]).push([[875],{5629:(e,t,n)=>{n.r(t),n.d(t,{assets:()=>d,contentTitle:()=>o,default:()=>p,frontMatter:()=>i,metadata:()=>s,toc:()=>c});const s=JSON.parse('{"id":"react-js/deep-dive/updating-objects","title":"Updating Object State Immutably in React","description":"In React, it\'s important to update state immutably, meaning that you should not modify the existing state object directly. Instead, you should create a new object that includes the updated values, which helps React track changes and trigger the necessary re-renders.","source":"@site/docs/react-js/deep-dive/updating-objects.md","sourceDirName":"react-js/deep-dive","slug":"/react-js/deep-dive/updating-objects","permalink":"/my-blogs/docs/react-js/deep-dive/updating-objects","draft":false,"unlisted":false,"tags":[],"version":"current","sidebarPosition":2,"frontMatter":{"sidebar_position":2},"sidebar":"tutorialSidebar","previous":{"title":"Updating State Based on Old State in React","permalink":"/my-blogs/docs/react-js/deep-dive/updating-state"},"next":{"title":"Lifting State Up in React","permalink":"/my-blogs/docs/react-js/deep-dive/lifting-state"}}');var r=n(4848),a=n(8453);const i={sidebar_position:2},o="Updating Object State Immutably in React",d={},c=[{value:"Why Immutability is Important",id:"why-immutability-is-important",level:2},{value:"1. <strong>Using <code>useState</code> Hook with Functional Components</strong>",id:"1-using-usestate-hook-with-functional-components",level:2},{value:"Example: Updating an Object in <code>useState</code>",id:"example-updating-an-object-in-usestate",level:3},{value:"Explanation:",id:"explanation",level:3},{value:"2. <strong>Nested Objects</strong>",id:"2-nested-objects",level:2},{value:"Example: Updating Nested Object State",id:"example-updating-nested-object-state",level:3},{value:"Explanation:",id:"explanation-1",level:3},{value:"3. <strong>Using <code>Object.assign()</code> (Alternative to Spread Operator)</strong>",id:"3-using-objectassign-alternative-to-spread-operator",level:2},{value:"Example with <code>Object.assign()</code>:",id:"example-with-objectassign",level:3},{value:"4. <strong>Using <code>useReducer</code> for Complex State Updates (Advanced)</strong>",id:"4-using-usereducer-for-complex-state-updates-advanced",level:2},{value:"Summary of Immutability Best Practices:",id:"summary-of-immutability-best-practices",level:2}];function l(e){const t={code:"code",h1:"h1",h2:"h2",h3:"h3",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,a.R)(),...e.components};return(0,r.jsxs)(r.Fragment,{children:[(0,r.jsx)(t.header,{children:(0,r.jsx)(t.h1,{id:"updating-object-state-immutably-in-react",children:"Updating Object State Immutably in React"})}),"\n",(0,r.jsxs)(t.p,{children:["In React, it's important to update state ",(0,r.jsx)(t.strong,{children:"immutably"}),", meaning that you should not modify the existing state object directly. Instead, you should create a ",(0,r.jsx)(t.strong,{children:"new object"})," that includes the updated values, which helps React track changes and trigger the necessary re-renders."]}),"\n",(0,r.jsx)(t.h2,{id:"why-immutability-is-important",children:"Why Immutability is Important"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Predictability"}),": React needs to know when state has changed in order to trigger re-renders. If you modify the state directly, React won\u2019t be able to detect the change because the reference to the state object remains the same."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Performance"}),": React uses a ",(0,r.jsx)(t.strong,{children:"shallow comparison"})," to check if the state has changed. If you mutate the state directly, the object reference doesn\u2019t change, and React might not re-render your component."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Debugging"}),": Keeping state immutable helps you avoid unintended side effects, making it easier to reason about and debug your application."]}),"\n"]}),"\n",(0,r.jsx)(t.h1,{id:"how-to-update-object-state-immutably",children:"How to Update Object State Immutably"}),"\n",(0,r.jsxs)(t.h2,{id:"1-using-usestate-hook-with-functional-components",children:["1. ",(0,r.jsxs)(t.strong,{children:["Using ",(0,r.jsx)(t.code,{children:"useState"})," Hook with Functional Components"]})]}),"\n",(0,r.jsx)(t.p,{children:"To update an object in the state immutably, you should create a new object and copy the old properties over, then update the specific property that you want to change."}),"\n",(0,r.jsxs)(t.h3,{id:"example-updating-an-object-in-usestate",children:["Example: Updating an Object in ",(0,r.jsx)(t.code,{children:"useState"})]}),"\n",(0,r.jsxs)(t.p,{children:["Let's say you have an object in the state that represents a ",(0,r.jsx)(t.strong,{children:"user profile"}),", and you want to update just one field (e.g., the ",(0,r.jsx)(t.code,{children:"name"}),")."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"import React, { useState } from 'react';\r\n\r\nfunction Profile() {\r\n  const [user, setUser] = useState({\r\n    name: 'John',\r\n    age: 30,\r\n    location: 'New York',\r\n  });\r\n\r\n  const updateName = () => {\r\n    // Updating the 'name' field immutably\r\n    setUser(prevUser => ({\r\n      ...prevUser,  // Spread the previous user object\r\n      name: 'Alice', // Update the 'name' field\r\n    }));\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <h1>Name: {user.name}</h1>\r\n      <p>Age: {user.age}</p>\r\n      <p>Location: {user.location}</p>\r\n      <button onClick={updateName}>Change Name</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default Profile;\n"})}),"\n",(0,r.jsx)(t.h3,{id:"explanation",children:"Explanation:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"...prevUser"})}),": The ",(0,r.jsxs)(t.strong,{children:["spread operator (",(0,r.jsx)(t.code,{children:"..."}),")"]})," copies all properties from the previous state (",(0,r.jsx)(t.code,{children:"prevUser"}),") into a new object."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"name: 'Alice'"})}),": You then update the specific field (",(0,r.jsx)(t.code,{children:"name"}),"), while all other properties (",(0,r.jsx)(t.code,{children:"age"}),", ",(0,r.jsx)(t.code,{children:"location"}),") remain unchanged."]}),"\n"]}),"\n",(0,r.jsxs)(t.h2,{id:"2-nested-objects",children:["2. ",(0,r.jsx)(t.strong,{children:"Nested Objects"})]}),"\n",(0,r.jsxs)(t.p,{children:["If your state contains ",(0,r.jsx)(t.strong,{children:"nested objects"})," (objects inside objects), you should also update those properties immutably by spreading the parent object, and then further spreading or updating the nested objects."]}),"\n",(0,r.jsx)(t.h3,{id:"example-updating-nested-object-state",children:"Example: Updating Nested Object State"}),"\n",(0,r.jsxs)(t.p,{children:["Suppose your state looks like this, where ",(0,r.jsx)(t.code,{children:"address"})," is a nested object:"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"import React, { useState } from 'react';\r\n\r\nfunction UserProfile() {\r\n  const [user, setUser] = useState({\r\n    name: 'John',\r\n    age: 30,\r\n    address: {\r\n      city: 'New York',\r\n      zipCode: '10001',\r\n    },\r\n  });\r\n\r\n  const updateCity = () => {\r\n    setUser(prevUser => ({\r\n      ...prevUser, // Copy the outer user object\r\n      address: {\r\n        ...prevUser.address, // Copy the previous address object\r\n        city: 'Los Angeles', // Update just the 'city'\r\n      },\r\n    }));\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <h1>{user.name}</h1>\r\n      <p>Age: {user.age}</p>\r\n      <p>City: {user.address.city}</p>\r\n      <p>Zip Code: {user.address.zipCode}</p>\r\n      <button onClick={updateCity}>Change City</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default UserProfile;\n"})}),"\n",(0,r.jsx)(t.h3,{id:"explanation-1",children:"Explanation:"}),"\n",(0,r.jsxs)(t.ul,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"...prevUser"})}),": This spreads the outer ",(0,r.jsx)(t.code,{children:"user"})," object, keeping all its properties."]}),"\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"...prevUser.address"})}),": This spreads the ",(0,r.jsx)(t.code,{children:"address"})," object, so that the ",(0,r.jsx)(t.code,{children:"city"})," is the only property getting updated, while the other properties in ",(0,r.jsx)(t.code,{children:"address"})," (like ",(0,r.jsx)(t.code,{children:"zipCode"}),") stay the same."]}),"\n"]}),"\n",(0,r.jsxs)(t.h2,{id:"3-using-objectassign-alternative-to-spread-operator",children:["3. ",(0,r.jsxs)(t.strong,{children:["Using ",(0,r.jsx)(t.code,{children:"Object.assign()"})," (Alternative to Spread Operator)"]})]}),"\n",(0,r.jsxs)(t.p,{children:["If you're working in an environment where the spread operator is not available (e.g., older JavaScript versions), you can use ",(0,r.jsx)(t.code,{children:"Object.assign()"})," to create a new object and copy properties from the old object."]}),"\n",(0,r.jsxs)(t.h3,{id:"example-with-objectassign",children:["Example with ",(0,r.jsx)(t.code,{children:"Object.assign()"}),":"]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"const updateCity = () => {\r\n  setUser(prevUser => Object.assign({}, prevUser, {\r\n    address: Object.assign({}, prevUser.address, {\r\n      city: 'Los Angeles',\r\n    }),\r\n  }));\r\n};\n"})}),"\n",(0,r.jsxs)(t.p,{children:["In this case, ",(0,r.jsx)(t.code,{children:"Object.assign()"})," is used to create a new object by copying the old properties and updating the specific fields."]}),"\n",(0,r.jsxs)(t.h2,{id:"4-using-usereducer-for-complex-state-updates-advanced",children:["4. ",(0,r.jsxs)(t.strong,{children:["Using ",(0,r.jsx)(t.code,{children:"useReducer"})," for Complex State Updates (Advanced)"]})]}),"\n",(0,r.jsxs)(t.p,{children:["When state updates become complex (e.g., deeply nested updates), using ",(0,r.jsx)(t.code,{children:"useReducer"})," is a great alternative. It allows for more structured and manageable state updates."]}),"\n",(0,r.jsx)(t.pre,{children:(0,r.jsx)(t.code,{className:"language-js",children:"import React, { useReducer } from 'react';\r\n\r\nconst initialState = {\r\n  name: 'John',\r\n  age: 30,\r\n  address: {\r\n    city: 'New York',\r\n    zipCode: '10001',\r\n  },\r\n};\r\n\r\nfunction reducer(state, action) {\r\n  switch (action.type) {\r\n    case 'UPDATE_CITY':\r\n      return {\r\n        ...state,\r\n        address: {\r\n          ...state.address,\r\n          city: action.payload, // Update the city\r\n        },\r\n      };\r\n    default:\r\n      return state;\r\n  }\r\n}\r\n\r\nfunction UserProfile() {\r\n  const [state, dispatch] = useReducer(reducer, initialState);\r\n\r\n  const updateCity = () => {\r\n    dispatch({ type: 'UPDATE_CITY', payload: 'Los Angeles' });\r\n  };\r\n\r\n  return (\r\n    <div>\r\n      <h1>{state.name}</h1>\r\n      <p>Age: {state.age}</p>\r\n      <p>City: {state.address.city}</p>\r\n      <button onClick={updateCity}>Change City</button>\r\n    </div>\r\n  );\r\n}\r\n\r\nexport default UserProfile;\n"})}),"\n",(0,r.jsx)(t.h2,{id:"summary-of-immutability-best-practices",children:"Summary of Immutability Best Practices:"}),"\n",(0,r.jsxs)(t.ol,{children:["\n",(0,r.jsxs)(t.li,{children:[(0,r.jsx)(t.strong,{children:"Never modify the state directly"}),". Always use a new object to represent the updated state."]}),"\n",(0,r.jsxs)(t.li,{children:["Use the ",(0,r.jsx)(t.strong,{children:"spread operator"})," (",(0,r.jsx)(t.code,{children:"..."}),") to copy the previous state and update the necessary properties."]}),"\n",(0,r.jsxs)(t.li,{children:["For ",(0,r.jsx)(t.strong,{children:"nested objects"}),", spread both the parent and child objects to ensure the changes are made immutably."]}),"\n",(0,r.jsxs)(t.li,{children:["Consider using ",(0,r.jsx)(t.strong,{children:(0,r.jsx)(t.code,{children:"useReducer"})})," for managing complex or deeply nested state updates."]}),"\n"]})]})}function p(e={}){const{wrapper:t}={...(0,a.R)(),...e.components};return t?(0,r.jsx)(t,{...e,children:(0,r.jsx)(l,{...e})}):l(e)}},8453:(e,t,n)=>{n.d(t,{R:()=>i,x:()=>o});var s=n(6540);const r={},a=s.createContext(r);function i(e){const t=s.useContext(a);return s.useMemo((function(){return"function"==typeof e?e(t):{...t,...e}}),[t,e])}function o(e){let t;return t=e.disableParentContext?"function"==typeof e.components?e.components(r):e.components||r:i(e.components),s.createElement(a.Provider,{value:t},e.children)}}}]);